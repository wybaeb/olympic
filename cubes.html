<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Посчитай кубики - развивающая игра</title>
<style>
    html,body{
        margin:0;
        padding:0;
        font-family:Arial, Helvetica, sans-serif;
        background:#f5f5f5;
        display:flex;
        flex-direction:column;
        align-items:center;
    }
    h1{margin:20px 0 10px;font-size:1.6rem;}
    .game-info {
        display: flex;
        justify-content: space-between;
        width: 600px;
        padding: 10px 0;
        margin-bottom: 10px;
        font-size: 1.2rem;
    }
    .level {
        font-weight: bold;
        color: #2196F3;
    }
    .progress {
        color: #4CAF50;
        font-weight: bold;
    }
    .input-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 15px;
        width: 100%;
        max-width: 600px;
        justify-content: center;
    }
    .input-container input {
        width: 80px;
        padding: 8px;
        font-size: 1.2rem;
        border: 2px solid #ccc;
        border-radius: 4px;
        text-align: center;
    }
    .input-container input:focus {
        border-color: #2196F3;
        outline: none;
    }
    .btn-next {
        padding: 8px 16px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1.2rem;
    }
    .btn-next:hover {
        background: #45a049;
    }
    canvas {
        background:#ffffff;
        box-shadow:0 2px 6px rgba(0,0,0,0.2);
        border-radius: 8px;
    }
    .message {
        margin-top: 15px;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: bold;
        font-size: 1.2rem;
        text-align: center;
        opacity: 0;
        transition: opacity 0.3s ease;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        min-width: 300px;
    }
    .success {
        background-color: rgba(76, 175, 80, 0.9);
        color: white;
    }
    .error {
        background-color: rgba(244, 67, 54, 0.9);
        color: white;
    }
    .level-up {
        background-color: rgba(33, 150, 243, 0.9);
        color: white;
        font-size: 1.5rem;
    }
    .game-container {
        position: relative;
    }
</style>
</head>
<body>
<h1>Посчитай кубики!</h1>

<div class="game-info">
    <div class="level">Уровень: <span id="currentLevel">1</span></div>
    <div class="progress">Прогресс: <span id="progress">0/3</span></div>
</div>

<div class="game-container">
<canvas id="canvas" width="600" height="450"></canvas>
    <div id="message" class="message"></div>
</div>

<div class="input-container">
    <label for="userAnswer">Сколько кубиков? </label>
    <input type="number" id="userAnswer" min="1">
    <button id="btnNext" class="btn-next">Далее</button>
</div>

<script>
(function(){
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const userAnswerInput = document.getElementById('userAnswer');
    const btnNext = document.getElementById('btnNext');
    const messageEl = document.getElementById('message');
    const levelEl = document.getElementById('currentLevel');
    const progressEl = document.getElementById('progress');

    // Игровые параметры
    let currentLevel = 1;
    let successCount = 0;
    let totalCubes = 0;
    let currentHeights = [];
    const maxGridSize = 7;  // Максимальный размер сетки 7x7
    const maxCubeHeight = 4;          // ограничиваем максимальную высоту башни

    // Цветовая палитра для кубиков
    const palette = [
        '#ffadad','#ffd6a5','#fdffb6','#caffbf',
        '#9bf6ff','#a0c4ff','#bdb2ff','#ffc6ff',
        '#ff9aa2','#ffb347','#98d8c8','#c5e0dc',
        '#f7cac9','#c5b9cd','#97c1a9','#fcf6bd'
    ];

    // Параметры отрисовки
    const cube = 30;                  // уменьшаем размер куба для большей платформы
    const originX = canvas.width/2;   // центр сцены по X
    const originY = 80;               // уменьшаем отступ сверху

    const isoAngle = Math.PI/6;       // 30 градусов - угол проекции
    const cos30 = Math.cos(isoAngle);
    const sin30 = Math.sin(isoAngle);

    // Корректное изометрическое преобразование координат
    function iso(ix, iy, iz) {
        const x = originX + (ix - iy) * cube * cos30;
        const y = originY + (ix + iy) * cube * sin30 - iz * cube * sin30 * 2;
        return {x, y};
    }

    // Рисуем базовую плоскость
    function drawBase(n) {
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;

        // Рисуем плоскость
        const points = [];
        points.push(iso(0, 0, 0));
        points.push(iso(n, 0, 0));
        points.push(iso(n, n, 0));
        points.push(iso(0, n, 0));

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.closePath();
        ctx.fillStyle = '#f0f0f0';
        ctx.fill();
        ctx.stroke();

        // Сетка
        ctx.strokeStyle = '#ddd';
        for(let i=0; i<=n; i++) {
            // Горизонтальные линии
            const start1 = iso(0, i, 0);
            const end1 = iso(n, i, 0);
            ctx.beginPath();
            ctx.moveTo(start1.x, start1.y);
            ctx.lineTo(end1.x, end1.y);
            ctx.stroke();

            // Вертикальные линии
            const start2 = iso(i, 0, 0);
            const end2 = iso(i, n, 0);
            ctx.beginPath();
            ctx.moveTo(start2.x, start2.y);
            ctx.lineTo(end2.x, end2.y);
            ctx.stroke();
        }
    }

    // Заливка полигона
    function poly(points, fill) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // Затенение/осветление цвета
    function shade(col, perc) {
        const num = parseInt(col.slice(1), 16);
        let r = (num>>16) + Math.round(2.55*perc);
        let g = (num>>8 & 0x00FF) + Math.round(2.55*perc);
        let b = (num & 0x0000FF) + Math.round(2.55*perc);
        r = (r<255)?((r<0)?0:r):255;
        g = (g<255)?((g<0)?0:g):255;
        b = (b<255)?((b<0)?0:b):255;
        return '#' + (0x1000000 + (r<<16) + (g<<8) + b).toString(16).slice(1);
    }

    // Рисуем куб
    function drawCube(ix, iy, iz, baseColor) {
        // Расчёт цветов для разных граней
        const cTop = shade(baseColor, 30);     // верхняя грань светлее
        const cLeft = shade(baseColor, -10);   // левая грань немного темнее
        const cRight = shade(baseColor, -20);  // правая грань ещё темнее
        
        // Координаты вершин куба в изометрии
        const topFrontLeft = iso(ix, iy, iz+1);      // верхняя-передняя-левая
        const topFrontRight = iso(ix+1, iy, iz+1);   // верхняя-передняя-правая
        const topBackRight = iso(ix+1, iy+1, iz+1);  // верхняя-задняя-правая
        const topBackLeft = iso(ix, iy+1, iz+1);     // верхняя-задняя-левая
        
        const bottomFrontLeft = iso(ix, iy, iz);     // нижняя-передняя-левая
        const bottomFrontRight = iso(ix+1, iy, iz);  // нижняя-передняя-правая
        const bottomBackRight = iso(ix+1, iy+1, iz); // нижняя-задняя-правая
        const bottomBackLeft = iso(ix, iy+1, iz);    // нижняя-задняя-левая
        
        // Вариант 10: Верхняя, правая, задняя грани
        // 1. Верхняя грань
        poly([topFrontLeft, topFrontRight, topBackRight, topBackLeft], cTop);
        // 2. Правая грань
        poly([topBackRight, topFrontRight, bottomFrontRight, bottomBackRight], cLeft);
        // 3. Задняя грань
        poly([topBackLeft, topBackRight, bottomBackRight, bottomBackLeft], cRight);
    }

    // Генерация случайного числа в диапазоне
    function rand(min, max) { 
        return Math.floor(Math.random() * (max - min + 1)) + min; 
    }

    // Создание нового задания
    function createNewTask() {
        // Очистим поле ввода
        userAnswerInput.value = '';
        userAnswerInput.focus();
        
        // Расчет целевого количества кубиков для текущего уровня
        const targetCubes = currentLevel + 3 + rand(0, 2);
        console.log(`Создаем задание для уровня ${currentLevel}, целевое количество кубиков: ${targetCubes}`);
        
        // Размер сетки фиксирован 7x7
        const gridSize = 7;
        
        // Генерируем высоты колонок
        const result = generateHeights(gridSize, targetCubes);
        currentHeights = result.heights;
        totalCubes = result.cubes;
        
        console.log(`Реальное количество кубиков: ${totalCubes}`);
        
        // Обновляем прогресс
        progressEl.textContent = `${successCount}/3`;
        
        // Отрисовываем
        drawScene();
    }

    // Генерируем таблицу высот с монотонным убыванием для однозначности подсчета
    function generateHeights(gridSize, targetCubes) {
        // Создаем пустую сетку
        let H = Array.from({length: gridSize}, () => Array(gridSize).fill(0));
        let remaining = targetCubes;
        
        // Определяем максимальную высоту башни
        const maxTowerHeight = Math.min(Math.ceil(targetCubes / 3), maxCubeHeight);
        
        // Создаем башни разной высоты
        const towers = [];
        
        // Генерируем до 12 башен разной высоты
        const maxTowers = Math.min(12, Math.ceil(targetCubes / 2));
        
        // Генерируем башни, начиная с самых высоких
        let currentHeight = maxTowerHeight;
        while (remaining > 0 && towers.length < maxTowers) {
            // Высота новой башни
            const height = Math.min(remaining, Math.max(1, currentHeight));
            
            towers.push({
                height: height,
                x: -1,  // будет установлено позже
                y: -1   // будет установлено позже
            });
            
            remaining -= height;
            
            // Уменьшаем высоту для следующей башни
            currentHeight = Math.max(1, currentHeight - 1);
            if (currentHeight === 1 && remaining > maxTowers - towers.length) {
                currentHeight = 2; // Увеличиваем минимальную высоту, если осталось много кубиков
            }
        }
        
        // Если остались кубики, добавляем еще башни высотой 1
        while (remaining > 0 && towers.length < gridSize * gridSize) {
            towers.push({
                height: 1,
                x: -1,
                y: -1
            });
            remaining -= 1;
        }
        
        // Случайно размещаем башни на сетке
        const availablePositions = [];
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                availablePositions.push({x: i, y: j});
            }
        }
        
        // Перемешиваем доступные позиции
        shuffleArray(availablePositions);
        
        // Сначала размещаем башни
        for (let i = 0; i < towers.length; i++) {
            if (i < availablePositions.length) {
                towers[i].x = availablePositions[i].x;
                towers[i].y = availablePositions[i].y;
            }
        }
        
        // Теперь проверяем, не перекрывают ли высокие башни низкие
        let swapsMade = true;
        while (swapsMade) {
            swapsMade = false;
            
            for (let i = 0; i < towers.length; i++) {
                for (let j = 0; j < towers.length; j++) {
                    if (i === j) continue;
                    
                    const tower1 = towers[i];
                    const tower2 = towers[j];
                    
                    // Если первая башня выше второй
                    if (tower1.height > tower2.height) {
                        // Проверяем, находится ли более высокая башня ближе к наблюдателю
                        // В изометрии ближе те клетки, у которых сумма координат меньше
                        const tower1Sum = tower1.x + tower1.y;
                        const tower2Sum = tower2.x + tower2.y;
                        
                        // Если высокая башня ближе к наблюдателю - меняем местами
                        if (tower1Sum < tower2Sum) {
                            // Меняем башни местами
                            [tower1.x, tower2.x] = [tower2.x, tower1.x];
                            [tower1.y, tower2.y] = [tower2.y, tower1.y];
                            swapsMade = true;
                        }
                    }
                }
            }
        }
        
        // Заполняем сетку высот из расположения башен
        for (const tower of towers) {
            H[tower.x][tower.y] = tower.height;
        }
        
        // Функция для случайного перемешивания массива
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        // Подсчет фактического количества кубиков
        let totalCubes = 0;
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                totalCubes += H[i][j];
            }
        }
        
        console.log(`Сгенерировано ${totalCubes} кубиков, целевое: ${targetCubes}`);
        return {heights: H, cubes: totalCubes};
    }

    // Отрисовка сцены
    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Фиксированный размер сетки 7x7
        const gridSize = 7;
        
        // Рисуем базовую плоскость
        drawBase(gridSize);
        
        // Подготавливаем колонки для отрисовки
        const columns = [];
        for(let i=0; i<gridSize; i++) {
            for(let j=0; j<gridSize; j++) {
                if (currentHeights[i] && currentHeights[i][j] > 0) {
                    columns.push({i, j, h: currentHeights[i][j]});
                }
            }
        }
        
        // Сортируем от дальних к ближним
        columns.sort((a, b) => (a.i + a.j) - (b.i + b.j));
        
        // Рисуем колонки кубов
        let renderedCount = 0;
        columns.forEach(col => {
            for(let z=0; z<col.h; z++) {
                renderedCount++;
                const color = palette[rand(0, palette.length-1)];
                drawCube(col.i, col.j, z, color);
            }
        });
        console.log(`Реально отрисовано: ${renderedCount} кубиков`);
    }

    // Показ сообщения
    function showMessage(text, type) {
        messageEl.textContent = text;
        messageEl.className = `message ${type}`;
        messageEl.style.opacity = 1;
        
        setTimeout(() => {
            messageEl.style.opacity = 0;
        }, 2000);
    }

    // Проверка ответа пользователя
    function checkAnswer() {
        const userAnswer = parseInt(userAnswerInput.value, 10);
        
        if (isNaN(userAnswer)) {
            showMessage('Введите число!', 'error');
            return;
        }
        
        if (userAnswer === totalCubes) {
            // Правильный ответ
            successCount++;
            
            if (successCount >= 3) {
                // Переход на следующий уровень
                currentLevel++;
                successCount = 0;
                levelEl.textContent = currentLevel;
                showMessage(`Поздравляем! Уровень ${currentLevel}`, 'level-up');
            } else {
                showMessage('Правильно!', 'success');
            }
            
            // Создаем новое задание
            setTimeout(createNewTask, 1500);
        } else {
            // Неправильный ответ
            successCount = 0;
            showMessage(`Неверно! Правильный ответ: ${Math.round(totalCubes)}`, 'error');
            progressEl.textContent = `${successCount}/3`;
            
            // Задержка перед новым заданием
            setTimeout(createNewTask, 2500);
        }
    }

    // Обработчики событий
    btnNext.addEventListener('click', checkAnswer);
    userAnswerInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            checkAnswer();
        }
    });

    // Инициализация игры
    function initGame() {
        levelEl.textContent = currentLevel;
        createNewTask();
    }

    // Запуск игры
    initGame();
})();
</script>
</body>
</html>
