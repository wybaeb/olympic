<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Посчитай кубики - развивающая игра</title>
<style>
    html,body{
        margin:0;
        padding:0;
        font-family:Arial, Helvetica, sans-serif;
        background:#f5f5f5;
        display:flex;
        flex-direction:column;
        align-items:center;
    }
    h1{margin:20px 0 10px;font-size:1.6rem;}
    .game-info {
        display: flex;
        justify-content: space-between;
        width: 600px;
        padding: 10px 0;
        margin-bottom: 10px;
        font-size: 1.2rem;
        align-items: center;
    }
    .level {
        font-weight: bold;
        color: #2196F3;
    }
    .progress {
        color: #4CAF50;
        font-weight: bold;
    }
    .input-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 15px;
        width: 100%;
        max-width: 600px;
        justify-content: center;
    }
    .input-container input {
        width: 80px;
        padding: 8px;
        font-size: 1.2rem;
        border: 2px solid #ccc;
        border-radius: 4px;
        text-align: center;
    }
    .input-container input:focus {
        border-color: #2196F3;
        outline: none;
    }
    .btn-next {
        padding: 8px 16px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1.2rem;
    }
    .btn-next:hover {
        background: #45a049;
    }
    canvas {
        background:#ffffff;
        box-shadow:0 2px 6px rgba(0,0,0,0.2);
        border-radius: 8px;
    }
    .message {
        margin-top: 15px;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: bold;
        font-size: 1.2rem;
        text-align: center;
        opacity: 0;
        transition: opacity 0.3s ease;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        min-width: 300px;
    }
    .success {
        background-color: rgba(76, 175, 80, 0.9);
        color: white;
    }
    .error {
        background-color: rgba(244, 67, 54, 0.9);
        color: white;
    }
    .level-up {
        background-color: rgba(33, 150, 243, 0.9);
        color: white;
        font-size: 1.5rem;
    }
    .game-container {
        position: relative;
    }
    .btn-flatten {
        padding: 5px 10px;
        background: #e0e0e0;
        color: #666;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: background 0.2s;
    }
    .btn-flatten:hover {
        background: #d0d0d0;
    }
    .btn-flatten:active {
        background: #c0c0c0;
    }
    .level-select-container {
        display: inline-block;
        margin-left: 10px;
        position: relative;
    }
    .level-select {
        padding: 4px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #fff;
        font-size: 0.9rem;
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23333'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 4px center;
        background-size: 16px;
        padding-right: 24px;
    }
    .level-select:focus {
        outline: none;
        border-color: #2196F3;
        box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
    }
</style>
</head>
<body>
<h1>Посчитай кубики!</h1>

<div class="game-info">
    <div class="level">
        Уровень: <span id="currentLevel">1</span>
        <div class="level-select-container">
            <select id="levelSelect" class="level-select" title="Выбрать уровень">
                <!-- Опции будут добавлены через JavaScript -->
            </select>
        </div>
    </div>
    <div class="progress">Прогресс: <span id="progress">0/3</span></div>
    <button id="btnFlatten" class="btn-flatten" title="Удерживайте для сжатия высоты">⇅</button>
</div>

<div class="game-container">
<canvas id="canvas" width="600" height="450"></canvas>
    <div id="message" class="message"></div>
</div>

<div class="input-container">
    <label for="userAnswer">Сколько кубиков? </label>
    <input type="number" id="userAnswer" min="1">
    <button id="btnNext" class="btn-next">Далее</button>
</div>

<script>
(function(){
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const userAnswerInput = document.getElementById('userAnswer');
    const btnNext = document.getElementById('btnNext');
    const messageEl = document.getElementById('message');
    const levelEl = document.getElementById('currentLevel');
    const progressEl = document.getElementById('progress');
    const btnFlatten = document.getElementById('btnFlatten');

    // Игровые параметры
    let currentLevel = 1;
    let successCount = 0;
    let totalCubes = 0;
    let currentHeights = [];
    let previousHeights = null;   // Добавляем хранение предыдущей композиции
    let compositionHistory = [];  // История последних композиций
    const HISTORY_SIZE = 5;       // Хранить последние 5 композиций
    const maxGridSize = 5;  // Максимальный размер сетки 5x5
    // Максимальная высота башни теперь зависит от уровня и будет вычисляться динамически
    let isFlattened = false;  // Флаг для отслеживания режима сжатия высоты
    const SECRET_KEY = "cub3C0unt!ng2023"; // Секретный ключ для шифрования уровня

    // Цветовая палитра для кубиков
    const palette = [
        '#ffadad','#ffd6a5','#fdffb6','#caffbf',
        '#9bf6ff','#a0c4ff','#bdb2ff','#ffc6ff',
        '#ff9aa2','#ffb347','#98d8c8','#c5e0dc',
        '#f7cac9','#c5b9cd','#97c1a9','#fcf6bd'
    ];

    // Параметры отрисовки
    const cube = 30;                  // уменьшаем размер куба для большей платформы
    const originX = canvas.width/2;   // центр сцены по X
    const originY = 180;              // смещаем площадку ниже

    const isoAngle = Math.PI/6;       // 30 градусов - угол проекции
    const cos30 = Math.cos(isoAngle);
    const sin30 = Math.sin(isoAngle);

    // Корректное изометрическое преобразование координат
    function iso(ix, iy, iz) {
        const x = originX + (ix - iy) * cube * cos30;
        // Уменьшаем высоту вдвое, если режим сжатия активен
        const heightMultiplier = isFlattened ? 1 : 2;
        const y = originY + (ix + iy) * cube * sin30 - iz * cube * sin30 * heightMultiplier;
        return {x, y};
    }

    // Рисуем базовую плоскость
    function drawBase(n) {
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;

        // Рисуем плоскость
        const points = [];
        points.push(iso(0, 0, 0));
        points.push(iso(n, 0, 0));
        points.push(iso(n, n, 0));
        points.push(iso(0, n, 0));

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
    }
        ctx.closePath();
        ctx.fillStyle = '#f0f0f0';
        ctx.fill();
        ctx.stroke();

        // Сетка
        ctx.strokeStyle = '#ddd';
        for(let i=0; i<=n; i++) {
            // Горизонтальные линии
            const start1 = iso(0, i, 0);
            const end1 = iso(n, i, 0);
            ctx.beginPath();
            ctx.moveTo(start1.x, start1.y);
            ctx.lineTo(end1.x, end1.y);
            ctx.stroke();

            // Вертикальные линии
            const start2 = iso(i, 0, 0);
            const end2 = iso(i, n, 0);
            ctx.beginPath();
            ctx.moveTo(start2.x, start2.y);
            ctx.lineTo(end2.x, end2.y);
            ctx.stroke();
        }
    }

    // Заливка полигона
    function poly(points, fill) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // Затенение/осветление цвета
    function shade(col, perc) {
        const num = parseInt(col.slice(1), 16);
        let r = (num>>16) + Math.round(2.55*perc);
        let g = (num>>8 & 0x00FF) + Math.round(2.55*perc);
        let b = (num & 0x0000FF) + Math.round(2.55*perc);
        r = (r<255)?((r<0)?0:r):255;
        g = (g<255)?((g<0)?0:g):255;
        b = (b<255)?((b<0)?0:b):255;
        return '#' + (0x1000000 + (r<<16) + (g<<8) + b).toString(16).slice(1);
    }

    // Рисуем куб
    function drawCube(ix, iy, iz, baseColor) {
        // Расчёт цветов для разных граней
        const cTop = shade(baseColor, 30);     // верхняя грань светлее
        const cLeft = shade(baseColor, -10);   // левая грань немного темнее
        const cRight = shade(baseColor, -20);  // правая грань ещё темнее
        
        // Координаты вершин куба в изометрии
        const topFrontLeft = iso(ix, iy, iz+1);      // верхняя-передняя-левая
        const topFrontRight = iso(ix+1, iy, iz+1);   // верхняя-передняя-правая
        const topBackRight = iso(ix+1, iy+1, iz+1);  // верхняя-задняя-правая
        const topBackLeft = iso(ix, iy+1, iz+1);     // верхняя-задняя-левая
        
        const bottomFrontLeft = iso(ix, iy, iz);     // нижняя-передняя-левая
        const bottomFrontRight = iso(ix+1, iy, iz);  // нижняя-передняя-правая
        const bottomBackRight = iso(ix+1, iy+1, iz); // нижняя-задняя-правая
        const bottomBackLeft = iso(ix, iy+1, iz);    // нижняя-задняя-левая
        
        // Вариант 10: Верхняя, правая, задняя грани
        // 1. Верхняя грань
        poly([topFrontLeft, topFrontRight, topBackRight, topBackLeft], cTop);
        // 2. Правая грань
        poly([topBackRight, topFrontRight, bottomFrontRight, bottomBackRight], cLeft);
        // 3. Задняя грань
        poly([topBackLeft, topBackRight, bottomBackRight, bottomBackLeft], cRight);
    }

    // Генерация случайного числа в диапазоне
    function rand(min, max) { 
        return Math.floor(Math.random() * (max - min + 1)) + min; 
    }

    // Функция для сравнения двух композиций башен
    function areCompositionsSimilar(current, previous) {
        if (!previous) return false;
        
        // Находим ненулевые элементы в обоих массивах
        const currentTowers = [];
        const previousTowers = [];
        
        for (let i = 0; i < maxGridSize; i++) {
            for (let j = 0; j < maxGridSize; j++) {
                if (current[i][j] > 0) {
                    currentTowers.push({x: i, y: j, h: current[i][j]});
                }
                if (previous[i][j] > 0) {
                    previousTowers.push({x: i, y: j, h: previous[i][j]});
                }
            }
        }
        
        // Если количество башен сильно отличается, композиции не похожи
        if (Math.abs(currentTowers.length - previousTowers.length) > 2) {
            return false;
        }
        
        // Проверяем схожесть расположения и высот башен
        let similarityScore = 0;
        const maxScore = Math.max(currentTowers.length, previousTowers.length);
        
        // Проверяем расположение башен
        const patternCurrent = currentTowers.map(t => `${t.x},${t.y}`).sort().join('|');
        const patternPrevious = previousTowers.map(t => `${t.x},${t.y}`).sort().join('|');
        
        // Если паттерны очень похожи, увеличиваем счетчик схожести
        if (patternCurrent === patternPrevious) {
            similarityScore += maxScore * 0.7;
        } else {
            // Проверяем процент совпадающих позиций
            const currentPositions = new Set(currentTowers.map(t => `${t.x},${t.y}`));
            const previousPositions = new Set(previousTowers.map(t => `${t.x},${t.y}`));
            let commonPositions = 0;
            
            for (const pos of currentPositions) {
                if (previousPositions.has(pos)) {
                    commonPositions++;
                }
            }
            
            const positionSimilarity = commonPositions / Math.min(currentPositions.size, previousPositions.size);
            if (positionSimilarity > 0.6) {
                similarityScore += maxScore * 0.5;
            }
            
            // Проверяем совпадение по высотам
            const heightsCurrent = currentTowers.map(t => t.h).sort().join('|');
            const heightsPrevious = previousTowers.map(t => t.h).sort().join('|');
            
            if (heightsCurrent === heightsPrevious) {
                similarityScore += maxScore * 0.4;
            } else {
                // Проверяем распределение высот
                const currentHeightCounts = {};
                const previousHeightCounts = {};
                
                currentTowers.forEach(t => {
                    currentHeightCounts[t.h] = (currentHeightCounts[t.h] || 0) + 1;
                });
                
                previousTowers.forEach(t => {
                    previousHeightCounts[t.h] = (previousHeightCounts[t.h] || 0) + 1;
                });
                
                let sameHeightDistribution = true;
                const allHeights = new Set([
                    ...Object.keys(currentHeightCounts), 
                    ...Object.keys(previousHeightCounts)
                ]);
                
                for (const h of allHeights) {
                    if ((currentHeightCounts[h] || 0) !== (previousHeightCounts[h] || 0)) {
                        sameHeightDistribution = false;
                        break;
                    }
                }
                
                if (sameHeightDistribution) {
                    similarityScore += maxScore * 0.3;
                }
            }
            
            // Проверяем общую форму композиции
            const centralTendencyCurrent = currentTowers.reduce((acc, t) => acc + t.x + t.y, 0) / currentTowers.length;
            const centralTendencyPrevious = previousTowers.reduce((acc, t) => acc + t.x + t.y, 0) / previousTowers.length;
            
            if (Math.abs(centralTendencyCurrent - centralTendencyPrevious) < 1) {
                similarityScore += maxScore * 0.2;
            }
        }
        
        // Если счетчик схожести превышает порог, считаем композиции похожими
        // Используем более строгий порог для определения схожести
        return (similarityScore / maxScore) > 0.5;
    }
    
    // Проверка схожести с историей композиций
    function isSimilarToHistory(current) {
        if (compositionHistory.length === 0) return false;
        
        // Проверяем схожесть с каждой композицией в истории
        for (const historic of compositionHistory) {
            if (areCompositionsSimilar(current, historic)) {
                return true;
            }
        }
        
        return false;
    }
    
    // Добавление текущей композиции в историю
    function addToHistory(composition) {
        compositionHistory.push(JSON.parse(JSON.stringify(composition)));
        
        // Ограничиваем размер истории
        if (compositionHistory.length > HISTORY_SIZE) {
            compositionHistory.shift();  // Удаляем самую старую композицию
        }
    }
    
    // Применяем случайную трансформацию к композиции для разнообразия
    function applyRandomTransformation(heights) {
        const newHeights = Array.from({length: maxGridSize}, () => Array(maxGridSize).fill(0));
        // Увеличиваем количество вариантов трансформаций с 4 до 8
        const transformType = rand(1, 8);
        
        switch (transformType) {
            case 1: 
                // Поворот на 90 градусов
                for (let i = 0; i < maxGridSize; i++) {
                    for (let j = 0; j < maxGridSize; j++) {
                        newHeights[maxGridSize - 1 - j][i] = heights[i][j];
                    }
                }
                break;
            case 2:
                // Поворот на 180 градусов
                for (let i = 0; i < maxGridSize; i++) {
                    for (let j = 0; j < maxGridSize; j++) {
                        newHeights[maxGridSize - 1 - i][maxGridSize - 1 - j] = heights[i][j];
                    }
                }
                break;
            case 3:
                // Поворот на 270 градусов
                for (let i = 0; i < maxGridSize; i++) {
                    for (let j = 0; j < maxGridSize; j++) {
                        newHeights[j][maxGridSize - 1 - i] = heights[i][j];
                    }
                }
                break;
            case 4:
                // Отражение по горизонтали
                for (let i = 0; i < maxGridSize; i++) {
                    for (let j = 0; j < maxGridSize; j++) {
                        newHeights[maxGridSize - 1 - i][j] = heights[i][j];
                    }
                }
                break;
            case 5:
                // Отражение по вертикали
                for (let i = 0; i < maxGridSize; i++) {
                    for (let j = 0; j < maxGridSize; j++) {
                        newHeights[i][maxGridSize - 1 - j] = heights[i][j];
                    }
                }
                break;
            case 6:
                // Диагональное отражение (основная диагональ)
                for (let i = 0; i < maxGridSize; i++) {
                    for (let j = 0; j < maxGridSize; j++) {
                        newHeights[j][i] = heights[i][j];
                    }
                }
                break;
            case 7:
                // Диагональное отражение (побочная диагональ)
                for (let i = 0; i < maxGridSize; i++) {
                    for (let j = 0; j < maxGridSize; j++) {
                        newHeights[maxGridSize - 1 - j][maxGridSize - 1 - i] = heights[i][j];
                    }
                }
                break;
            case 8:
                // Случайное смещение всей композиции в допустимых пределах
                // Находим границы занятой области
                let minX = maxGridSize, minY = maxGridSize, maxX = 0, maxY = 0;
                for (let i = 0; i < maxGridSize; i++) {
                    for (let j = 0; j < maxGridSize; j++) {
                        if (heights[i][j] > 0) {
                            minX = Math.min(minX, i);
                            minY = Math.min(minY, j);
                            maxX = Math.max(maxX, i);
                            maxY = Math.max(maxY, j);
                        }
                    }
                }
                
                // Вычисляем доступное пространство для смещения
                const width = maxX - minX + 1;
                const height = maxY - minY + 1;
                const maxDeltaX = maxGridSize - width;
                const maxDeltaY = maxGridSize - height;
                
                if (maxDeltaX > 0 || maxDeltaY > 0) {
                    const deltaX = maxDeltaX > 0 ? rand(0, maxDeltaX) - minX : -minX;
                    const deltaY = maxDeltaY > 0 ? rand(0, maxDeltaY) - minY : -minY;
                    
                    // Смещаем композицию
                    for (let i = 0; i < maxGridSize; i++) {
                        for (let j = 0; j < maxGridSize; j++) {
                            const srcI = i - deltaX;
                            const srcJ = j - deltaY;
                            
                            if (srcI >= 0 && srcI < maxGridSize && srcJ >= 0 && srcJ < maxGridSize) {
                                newHeights[i][j] = heights[srcI][srcJ];
                            }
                        }
                    }
                } else {
                    // Если смещение невозможно, просто копируем оригинал
                    for (let i = 0; i < maxGridSize; i++) {
                        for (let j = 0; j < maxGridSize; j++) {
                            newHeights[i][j] = heights[i][j];
                        }
                    }
                }
                break;
        }
        
        // Необходимо проверить, чтобы трансформация сохраняла условие видимости
        // и чтобы башни были соединены друг с другом
        let isValid = true;
        
        // Проверяем, не перекрывают ли высокие башни низкие с точки зрения наблюдателя
        const towers = [];
        for (let i = 0; i < maxGridSize; i++) {
            for (let j = 0; j < maxGridSize; j++) {
                if (newHeights[i][j] > 0) {
                    towers.push({x: i, y: j, h: newHeights[i][j]});
                }
            }
        }
        
        // Проверка на перекрытие
        for (let i = 0; i < towers.length; i++) {
            for (let j = 0; j < towers.length; j++) {
                if (i === j) continue;
                
                const tower1 = towers[i];
                const tower2 = towers[j];
                
                // Если первая башня выше второй и находится ближе к наблюдателю
                if (tower1.h > tower2.h && (tower1.x + tower1.y > tower2.x + tower2.y)) {
                    isValid = false;
                    break;
                }
            }
            if (!isValid) break;
        }
        
        // Проверка на соединенность (все башни должны быть связаны друг с другом)
        if (isValid && towers.length > 0) {
            const visited = new Set();
            const queue = [towers[0]];
            
            while (queue.length > 0) {
                const current = queue.shift();
                const key = `${current.x},${current.y}`;
                
                if (!visited.has(key)) {
                    visited.add(key);
                    
                    // Добавляем соседние башни в очередь
                    const neighbors = [
                        {x: current.x + 1, y: current.y},
                        {x: current.x - 1, y: current.y},
                        {x: current.x, y: current.y + 1},
                        {x: current.x, y: current.y - 1}
                    ];
                    
                    for (const neighbor of neighbors) {
                        if (newHeights[neighbor.x] && newHeights[neighbor.x][neighbor.y] > 0) {
                            const neighborKey = `${neighbor.x},${neighbor.y}`;
                            if (!visited.has(neighborKey)) {
                                queue.push(neighbor);
                            }
                        }
                    }
                }
            }
            
            // Если не все башни были посещены, значит, они не соединены
            if (visited.size !== towers.length) {
                isValid = false;
            }
        }
        
        // Если трансформация нарушает условие видимости или соединенности, 
        // используем оригинальную композицию
        return isValid ? newHeights : heights;
    }

    // Модифицируем createNewTask, чтобы не допускать похожие композиции
    function createNewTask() {
        // Очистим поле ввода
        userAnswerInput.value = '';
        userAnswerInput.focus();
        
        // Расчет целевого количества кубиков для текущего уровня
        const targetCubes = currentLevel + 3 + rand(0, 2);
        console.log(`Создаем задание для уровня ${currentLevel}, целевое количество кубиков: ${targetCubes}`);
        
        // Размер сетки фиксирован 5x5
        const gridSize = 5;
        
        // Генерируем высоты колонок, избегая похожих композиций
        let result;
        let maxAttempts = 5; // Увеличиваем количество попыток перегенерации
        let attempts = 0;
        let isSimilar = false;
        
        do {
            result = generateHeights(gridSize, targetCubes);
            attempts++;
            
            // Проверяем схожесть с предыдущей композицией и с историей
            isSimilar = areCompositionsSimilar(result.heights, previousHeights) || 
                       isSimilarToHistory(result.heights);
            
            // Если композиция похожа и у нас еще есть попытки, пробуем применить трансформацию
            if (isSimilar && attempts <= maxAttempts) {
                // Применяем до 3 разных трансформаций, пытаясь найти уникальную композицию
                for (let i = 0; i < 3; i++) {
                    const transformedHeights = applyRandomTransformation(result.heights);
                    
                    // Если трансформация дала результат, отличный от исходного
                    if (JSON.stringify(transformedHeights) !== JSON.stringify(result.heights)) {
                        result.heights = transformedHeights;
                        
                        // Пересчитываем количество кубиков после трансформации
                        result.cubes = 0;
                        for (let i = 0; i < gridSize; i++) {
                            for (let j = 0; j < gridSize; j++) {
                                result.cubes += result.heights[i][j];
                            }
                        }
                        
                        // Проверяем еще раз после трансформации
                        isSimilar = areCompositionsSimilar(result.heights, previousHeights) || 
                                   isSimilarToHistory(result.heights);
                        
                        if (!isSimilar) break; // Если нашли уникальную композицию, выходим из цикла
                    }
                }
            }
            
        } while (isSimilar && attempts < maxAttempts);
        
        // Сохраняем текущую композицию для следующего сравнения
        previousHeights = JSON.parse(JSON.stringify(result.heights));
        // Добавляем в историю
        addToHistory(result.heights);
        
        currentHeights = result.heights;
        totalCubes = result.cubes;
        
        console.log(`Реальное количество кубиков: ${totalCubes}, попыток: ${attempts}`);
        
        // Обновляем прогресс
        progressEl.textContent = `${successCount}/3`;
        
        // Отрисовываем
        drawScene();
    }

    // Генерируем таблицу высот с монотонным убыванием для однозначности подсчета
    function generateHeights(gridSize, targetCubes) {
        // Создаем пустую сетку
        let H = Array.from({length: gridSize}, () => Array(gridSize).fill(0));
        let remaining = targetCubes;
        
        // Определяем максимальную высоту башни в зависимости от уровня
        // Базовая высота 4 для начальных уровней, далее растет с уровнем
        const maxTowerHeight = Math.min(
            Math.max(3, Math.floor(currentLevel / 25) + 3), 
            Math.ceil(targetCubes / 4)
        );
        
        // Создаем башни разной высоты
        const towers = [];
        
        // Генерируем до 12 башен разной высоты, но для высоких уровней увеличиваем лимит
        const maxTowers = Math.min(Math.max(15, Math.floor(currentLevel / 10) + 15), Math.ceil(targetCubes * 0.7));
        
        // Генерируем башни, начиная с самых высоких
        let currentHeight = maxTowerHeight;
        while (remaining > 0 && towers.length < maxTowers) {
            // Высота новой башни
            const height = Math.min(remaining, Math.max(1, Math.min(currentHeight, Math.floor(targetCubes / (maxTowers * 0.7)))));
            
            towers.push({
                height: height,
                x: -1,  // будет установлено позже
                y: -1   // будет установлено позже
            });
            
            remaining -= height;
            
            // Уменьшаем высоту для следующей башни более агрессивно
            currentHeight = Math.max(1, currentHeight - (Math.random() > 0.3 ? 1 : 0));
            if (currentHeight === 1 && remaining > maxTowers - towers.length) {
                currentHeight = 2; // Увеличиваем минимальную высоту, если осталось много кубиков
            }
        }
        
        // Если остались кубики, добавляем еще башни высотой 1
        while (remaining > 0 && towers.length < gridSize * gridSize) {
            towers.push({
                height: 1,
                x: -1,
                y: -1
            });
            remaining -= 1;
        }
        
        // Сортируем башни по высоте от высоких к низким
        towers.sort((a, b) => b.height - a.height);
        
        // Размещаем башни на сетке по спирали с учетом высоты
        // Начинаем с верхнего левого угла (дальше от наблюдателя)
        // и двигаемся по спирали к правому нижнему (ближе к наблюдателю)
        
        // Определяем начальную позицию (верхний левый угол)
        let startX = 0;
        let startY = 0;
        
        // Размещаем первую (самую высокую) башню в начальной точке
        if (towers.length > 0) {
            towers[0].x = startX;
            towers[0].y = startY;
        }
        
        // Размещаем остальные башни по соседству
        if (towers.length > 1) {
            // Создаем массив доступных соседних клеток
            let availableCells = [];
            
            // Функция для добавления соседних клеток в список доступных
            function addNeighborCells(x, y) {
                const neighbors = [
                    {x: x+1, y: y},   // справа
                    {x: x, y: y+1},   // снизу
                    {x: x-1, y: y},   // слева
                    {x: x, y: y-1}    // сверху
                ];
                
                for (const neighbor of neighbors) {
                    // Проверяем, что клетка в пределах сетки
                    if (neighbor.x >= 0 && neighbor.x < gridSize && 
                        neighbor.y >= 0 && neighbor.y < gridSize) {
                        
                        // Проверяем, что клетка не занята
                        if (H[neighbor.x][neighbor.y] === 0) {
                            
                            // Проверяем, что эта клетка еще не в списке доступных
                            if (!availableCells.some(cell => cell.x === neighbor.x && cell.y === neighbor.y)) {
                                // Вычисляем приоритет для сортировки
                                // Чем меньше сумма координат, тем дальше от наблюдателя
                                const priority = neighbor.x + neighbor.y;
                                availableCells.push({...neighbor, priority});
                            }
                        }
                    }
                }
            }
            
            // Добавляем соседей первой башни
            addNeighborCells(towers[0].x, towers[0].y);
            
            // Размещаем остальные башни
            for (let i = 1; i < towers.length; i++) {
                if (availableCells.length === 0) {
                    console.log("Не удалось разместить все башни рядом друг с другом");
                    break;
                }
                
                // Сортируем доступные клетки по приоритету
                // Для высоких башен выбираем клетки дальше от наблюдателя (с меньшим приоритетом)
                availableCells.sort((a, b) => a.priority - b.priority);
                
                // Выбираем подходящую клетку в зависимости от высоты башни
                let selectedCellIndex = 0;
                if (towers[i].height > 1) {
                    // Для высоких башен выбираем клетки дальше от наблюдателя
                    selectedCellIndex = 0; // Клетка с наименьшей суммой координат
                } else {
                    // Для низких башен (высотой 1) можно выбрать любую доступную клетку
                    selectedCellIndex = Math.min(availableCells.length - 1, Math.floor(availableCells.length / 2));
                }
                
                const selectedCell = availableCells[selectedCellIndex];
                
                // Размещаем башню
                towers[i].x = selectedCell.x;
                towers[i].y = selectedCell.y;
                
                // Помечаем клетку как занятую
                H[selectedCell.x][selectedCell.y] = towers[i].height;
                
                // Удаляем выбранную клетку из списка доступных
                availableCells.splice(selectedCellIndex, 1);
                
                // Добавляем соседей текущей башни в список доступных
                addNeighborCells(towers[i].x, towers[i].y);
            }
        }
        
        // Заполняем сетку высот из расположения башен
        for (const tower of towers) {
            if (tower.x >= 0 && tower.y >= 0) {
                H[tower.x][tower.y] = tower.height;
            }
        }
        
        // Подсчет фактического количества кубиков
        let totalCubes = 0;
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                totalCubes += H[i][j];
            }
        }
        
        console.log(`Сгенерировано ${totalCubes} кубиков, целевое: ${targetCubes}`);
        return {heights: H, cubes: totalCubes};
    }

    // Отрисовка сцены
    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Фиксированный размер сетки 5x5
        const gridSize = 5;
        
        // Рисуем базовую плоскость
        drawBase(gridSize);
        
        // Подготавливаем колонки для отрисовки
        const columns = [];
        for(let i=0; i<gridSize; i++) {
            for(let j=0; j<gridSize; j++) {
                if (currentHeights[i] && currentHeights[i][j] > 0) {
                    columns.push({i, j, h: currentHeights[i][j]});
            }
        }
        }
        
        // Сортируем от дальних к ближним
        columns.sort((a, b) => (a.i + a.j) - (b.i + b.j));
        
        // Рисуем колонки кубов
        let renderedCount = 0;
        columns.forEach(col => {
            for(let z=0; z<col.h; z++) {
                renderedCount++;
                const color = palette[rand(0, palette.length-1)];
                drawCube(col.i, col.j, z, color);
            }
        });
        console.log(`Реально отрисовано: ${renderedCount} кубиков`);
    }

    // Показ сообщения
    function showMessage(text, type) {
        messageEl.textContent = text;
        messageEl.className = `message ${type}`;
        messageEl.style.opacity = 1;
        
        setTimeout(() => {
            messageEl.style.opacity = 0;
        }, 2000);
    }

    // Проверка ответа пользователя
    function checkAnswer() {
        const userAnswer = parseInt(userAnswerInput.value, 10);
        
        if (isNaN(userAnswer)) {
            showMessage('Введите число!', 'error');
            return;
        }
        
        if (userAnswer === totalCubes) {
            // Правильный ответ
            successCount++;
            
            if (successCount >= 3) {
                // Переход на следующий уровень
                currentLevel++;
                successCount = 0;
                levelEl.textContent = currentLevel;
                showMessage(`Поздравляем! Уровень ${currentLevel}`, 'level-up');
                
                // Обновляем хеш в URL
                updateLevelHash();
            } else {
                showMessage('Правильно!', 'success');
            }
            
            // Создаем новое задание
            setTimeout(createNewTask, 1500);
        } else {
            // Неправильный ответ
            successCount = 0;
            showMessage(`Неверно! Правильный ответ: ${Math.round(totalCubes)}`, 'error');
            progressEl.textContent = `${successCount}/3`;
            
            // Задержка перед новым заданием
            setTimeout(createNewTask, 2500);
        }
    }

    // Обработчики событий
    btnNext.addEventListener('click', checkAnswer);
    userAnswerInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            checkAnswer();
        }
    });

    // Обработчики для кнопки сжатия высоты
    btnFlatten.addEventListener('mousedown', () => {
        isFlattened = true;
        drawScene();
    });

    btnFlatten.addEventListener('mouseup', () => {
        isFlattened = false;
        drawScene();
        userAnswerInput.focus();
    });

    btnFlatten.addEventListener('mouseleave', () => {
        isFlattened = false;
        drawScene();
    });

    // Для поддержки тач-устройств
    btnFlatten.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isFlattened = true;
        drawScene();
    });

    btnFlatten.addEventListener('touchend', () => {
        isFlattened = false;
        drawScene();
        userAnswerInput.focus();
    });

    // Инициализация игры
    function initGame() {
        // Заполняем выпадающий список уровней
        const levelSelect = document.getElementById('levelSelect');
        for (let i = 1; i <= 100; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = `Уровень ${i}`;
            levelSelect.appendChild(option);
        }
        
        // Добавляем обработчик события изменения уровня
        levelSelect.addEventListener('change', function() {
            const selectedLevel = parseInt(this.value);
            if (selectedLevel !== currentLevel) {
                currentLevel = selectedLevel;
                successCount = 0;
                levelEl.textContent = currentLevel;
                progressEl.textContent = `${successCount}/3`;
                updateLevelHash();
                createNewTask();
                showMessage(`Переход на уровень ${currentLevel}`, 'level-up');
            }
        });
        
        // Проверяем хеш в URL
        checkLevelFromHash();
        
        // Обновляем выпадающий список в соответствии с текущим уровнем
        levelSelect.value = currentLevel;
        
        levelEl.textContent = currentLevel;
        createNewTask();
    }

    // Функция для проверки хеша в URL и установки соответствующего уровня
    function checkLevelFromHash() {
        const hash = window.location.hash.substr(1);
        if (hash && hash.length > 0) {
            try {
                const level = decodeLevelFromHash(hash);
                if (level && level > 0 && level <= 100) { // Ограничиваем максимальный уровень
                    currentLevel = level;
                    console.log(`Восстановлен уровень: ${level} из хеша`);
                }
            } catch (e) {
                console.log("Некорректный хеш уровня");
            }
        }
    }

    // Функция для обновления хеша в URL при изменении уровня
    function updateLevelHash() {
        const hash = encodeLevelToHash(currentLevel);
        window.location.hash = hash;
        
        // Обновляем значение выпадающего списка
        const levelSelect = document.getElementById('levelSelect');
        levelSelect.value = currentLevel;
    }

    // Функция для генерации сложного хеша на основе номера уровня
    function encodeLevelToHash(level) {
        // Создаем случайную "соль" для усложнения хеша
        const salt = generateRandomString(5);
        
        // Преобразуем уровень в строку и добавляем соль
        const levelStr = level.toString().padStart(3, '0');
        
        // XOR шифрование с ключом
        let encoded = '';
        for (let i = 0; i < levelStr.length; i++) {
            const charCode = levelStr.charCodeAt(i);
            const keyChar = SECRET_KEY.charCodeAt(i % SECRET_KEY.length);
            encoded += String.fromCharCode(charCode ^ keyChar);
        }
        
        // Добавляем соль и время (для уникальности)
        const timestamp = Date.now() % 10000;
        const dataToEncode = salt + encoded + timestamp.toString();
        
        // Кодируем в Base64
        return btoa(dataToEncode).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
    }

    // Функция для декодирования хеша в номер уровня
    function decodeLevelFromHash(hash) {
        try {
            // Декодируем из Base64
            const decoded = atob(hash.replace(/-/g, '+').replace(/_/g, '/'));
            
            // Убираем соль (первые 5 символов) и timestamp (последние 4 символа)
            const encodedLevel = decoded.substr(5, 3);
            
            // XOR дешифрование с ключом
            let levelStr = '';
            for (let i = 0; i < encodedLevel.length; i++) {
                const charCode = encodedLevel.charCodeAt(i);
                const keyChar = SECRET_KEY.charCodeAt(i % SECRET_KEY.length);
                levelStr += String.fromCharCode(charCode ^ keyChar);
            }
            
            // Преобразуем в число
            return parseInt(levelStr, 10);
        } catch (e) {
            console.error("Ошибка декодирования хеша", e);
            return null;
        }
    }

    // Генерация случайной строки заданной длины
    function generateRandomString(length) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    // Запуск игры
    initGame();
})();
</script>
</body>
</html>
