<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Посчитай кубики - развивающая игра</title>
<style>
    html,body{
        margin:0;
        padding:0;
        font-family:Arial, Helvetica, sans-serif;
        background:#f5f5f5;
        display:flex;
        flex-direction:column;
        align-items:center;
    }
    h1{margin:20px 0 10px;font-size:1.6rem;}
    .game-info {
        display: flex;
        justify-content: space-between;
        width: 600px;
        padding: 10px 0;
        margin-bottom: 10px;
        font-size: 1.2rem;
        align-items: center;
    }
    .level {
        font-weight: bold;
        color: #2196F3;
    }
    .progress {
        color: #4CAF50;
        font-weight: bold;
    }
    .input-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 15px;
        width: 100%;
        max-width: 600px;
        justify-content: center;
    }
    .input-container input {
        width: 80px;
        padding: 8px;
        font-size: 1.2rem;
        border: 2px solid #ccc;
        border-radius: 4px;
        text-align: center;
    }
    .input-container input:focus {
        border-color: #2196F3;
        outline: none;
    }
    .btn-next {
        padding: 8px 16px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1.2rem;
    }
    .btn-next:hover {
        background: #45a049;
    }
    canvas {
        background:#ffffff;
        box-shadow:0 2px 6px rgba(0,0,0,0.2);
        border-radius: 8px;
    }
    .message {
        margin-top: 15px;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: bold;
        font-size: 1.2rem;
        text-align: center;
        opacity: 0;
        transition: opacity 0.3s ease;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        min-width: 300px;
    }
    .success {
        background-color: rgba(76, 175, 80, 0.9);
        color: white;
    }
    .error {
        background-color: rgba(244, 67, 54, 0.9);
        color: white;
    }
    .level-up {
        background-color: rgba(33, 150, 243, 0.9);
        color: white;
        font-size: 1.5rem;
    }
    .game-container {
        position: relative;
    }
    .btn-flatten {
        padding: 5px 10px;
        background: #e0e0e0;
        color: #666;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: background 0.2s;
    }
    .btn-flatten:hover {
        background: #d0d0d0;
    }
    .btn-flatten:active {
        background: #c0c0c0;
    }
</style>
</head>
<body>
<h1>Посчитай кубики!</h1>

<div class="game-info">
    <div class="level">Уровень: <span id="currentLevel">1</span></div>
    <div class="progress">Прогресс: <span id="progress">0/3</span></div>
    <button id="btnFlatten" class="btn-flatten" title="Удерживайте для сжатия высоты">⇅</button>
</div>

<div class="game-container">
<canvas id="canvas" width="600" height="450"></canvas>
    <div id="message" class="message"></div>
</div>

<div class="input-container">
    <label for="userAnswer">Сколько кубиков? </label>
    <input type="number" id="userAnswer" min="1">
    <button id="btnNext" class="btn-next">Далее</button>
</div>

<script>
(function(){
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const userAnswerInput = document.getElementById('userAnswer');
    const btnNext = document.getElementById('btnNext');
    const messageEl = document.getElementById('message');
    const levelEl = document.getElementById('currentLevel');
    const progressEl = document.getElementById('progress');
    const btnFlatten = document.getElementById('btnFlatten');

    // Игровые параметры
    let currentLevel = 1;
    let successCount = 0;
    let totalCubes = 0;
    let currentHeights = [];
    const maxGridSize = 5;  // Максимальный размер сетки 5x5
    const maxCubeHeight = 4;          // ограничиваем максимальную высоту башни
    let isFlattened = false;  // Флаг для отслеживания режима сжатия высоты
    const SECRET_KEY = "cub3C0unt!ng2023"; // Секретный ключ для шифрования уровня

    // Цветовая палитра для кубиков
    const palette = [
        '#ffadad','#ffd6a5','#fdffb6','#caffbf',
        '#9bf6ff','#a0c4ff','#bdb2ff','#ffc6ff',
        '#ff9aa2','#ffb347','#98d8c8','#c5e0dc',
        '#f7cac9','#c5b9cd','#97c1a9','#fcf6bd'
    ];

    // Параметры отрисовки
    const cube = 30;                  // уменьшаем размер куба для большей платформы
    const originX = canvas.width/2;   // центр сцены по X
    const originY = 180;              // смещаем площадку ниже

    const isoAngle = Math.PI/6;       // 30 градусов - угол проекции
    const cos30 = Math.cos(isoAngle);
    const sin30 = Math.sin(isoAngle);

    // Корректное изометрическое преобразование координат
    function iso(ix, iy, iz) {
        const x = originX + (ix - iy) * cube * cos30;
        // Уменьшаем высоту вдвое, если режим сжатия активен
        const heightMultiplier = isFlattened ? 1 : 2;
        const y = originY + (ix + iy) * cube * sin30 - iz * cube * sin30 * heightMultiplier;
        return {x, y};
    }

    // Рисуем базовую плоскость
    function drawBase(n) {
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;

        // Рисуем плоскость
        const points = [];
        points.push(iso(0, 0, 0));
        points.push(iso(n, 0, 0));
        points.push(iso(n, n, 0));
        points.push(iso(0, n, 0));

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
    }
        ctx.closePath();
        ctx.fillStyle = '#f0f0f0';
        ctx.fill();
        ctx.stroke();

        // Сетка
        ctx.strokeStyle = '#ddd';
        for(let i=0; i<=n; i++) {
            // Горизонтальные линии
            const start1 = iso(0, i, 0);
            const end1 = iso(n, i, 0);
            ctx.beginPath();
            ctx.moveTo(start1.x, start1.y);
            ctx.lineTo(end1.x, end1.y);
            ctx.stroke();

            // Вертикальные линии
            const start2 = iso(i, 0, 0);
            const end2 = iso(i, n, 0);
            ctx.beginPath();
            ctx.moveTo(start2.x, start2.y);
            ctx.lineTo(end2.x, end2.y);
            ctx.stroke();
        }
    }

    // Заливка полигона
    function poly(points, fill) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // Затенение/осветление цвета
    function shade(col, perc) {
        const num = parseInt(col.slice(1), 16);
        let r = (num>>16) + Math.round(2.55*perc);
        let g = (num>>8 & 0x00FF) + Math.round(2.55*perc);
        let b = (num & 0x0000FF) + Math.round(2.55*perc);
        r = (r<255)?((r<0)?0:r):255;
        g = (g<255)?((g<0)?0:g):255;
        b = (b<255)?((b<0)?0:b):255;
        return '#' + (0x1000000 + (r<<16) + (g<<8) + b).toString(16).slice(1);
    }

    // Рисуем куб
    function drawCube(ix, iy, iz, baseColor) {
        // Расчёт цветов для разных граней
        const cTop = shade(baseColor, 30);     // верхняя грань светлее
        const cLeft = shade(baseColor, -10);   // левая грань немного темнее
        const cRight = shade(baseColor, -20);  // правая грань ещё темнее
        
        // Координаты вершин куба в изометрии
        const topFrontLeft = iso(ix, iy, iz+1);      // верхняя-передняя-левая
        const topFrontRight = iso(ix+1, iy, iz+1);   // верхняя-передняя-правая
        const topBackRight = iso(ix+1, iy+1, iz+1);  // верхняя-задняя-правая
        const topBackLeft = iso(ix, iy+1, iz+1);     // верхняя-задняя-левая
        
        const bottomFrontLeft = iso(ix, iy, iz);     // нижняя-передняя-левая
        const bottomFrontRight = iso(ix+1, iy, iz);  // нижняя-передняя-правая
        const bottomBackRight = iso(ix+1, iy+1, iz); // нижняя-задняя-правая
        const bottomBackLeft = iso(ix, iy+1, iz);    // нижняя-задняя-левая
        
        // Вариант 10: Верхняя, правая, задняя грани
        // 1. Верхняя грань
        poly([topFrontLeft, topFrontRight, topBackRight, topBackLeft], cTop);
        // 2. Правая грань
        poly([topBackRight, topFrontRight, bottomFrontRight, bottomBackRight], cLeft);
        // 3. Задняя грань
        poly([topBackLeft, topBackRight, bottomBackRight, bottomBackLeft], cRight);
    }

    // Генерация случайного числа в диапазоне
    function rand(min, max) { 
        return Math.floor(Math.random() * (max - min + 1)) + min; 
    }

    // Создание нового задания
    function createNewTask() {
        // Очистим поле ввода
        userAnswerInput.value = '';
        userAnswerInput.focus();
        
        // Расчет целевого количества кубиков для текущего уровня
        const targetCubes = currentLevel + 3 + rand(0, 2);
        console.log(`Создаем задание для уровня ${currentLevel}, целевое количество кубиков: ${targetCubes}`);
        
        // Размер сетки фиксирован 5x5
        const gridSize = 5;
        
        // Генерируем высоты колонок
        const result = generateHeights(gridSize, targetCubes);
        currentHeights = result.heights;
        totalCubes = result.cubes;
        
        console.log(`Реальное количество кубиков: ${totalCubes}`);
        
        // Обновляем прогресс
        progressEl.textContent = `${successCount}/3`;
        
        // Отрисовываем
        drawScene();
    }

    // Генерируем таблицу высот с монотонным убыванием для однозначности подсчета
    function generateHeights(gridSize, targetCubes) {
        // Создаем пустую сетку
        let H = Array.from({length: gridSize}, () => Array(gridSize).fill(0));
        let remaining = targetCubes;
        
        // Определяем максимальную высоту башни
        const maxTowerHeight = Math.min(Math.ceil(targetCubes / 3), maxCubeHeight);
        
        // Создаем башни разной высоты
        const towers = [];
        
        // Генерируем до 12 башен разной высоты
        const maxTowers = Math.min(12, Math.ceil(targetCubes / 2));
        
        // Генерируем башни, начиная с самых высоких
        let currentHeight = maxTowerHeight;
        while (remaining > 0 && towers.length < maxTowers) {
            // Высота новой башни
            const height = Math.min(remaining, Math.max(1, currentHeight));
            
            towers.push({
                height: height,
                x: -1,  // будет установлено позже
                y: -1   // будет установлено позже
            });
            
            remaining -= height;
            
            // Уменьшаем высоту для следующей башни
            currentHeight = Math.max(1, currentHeight - 1);
            if (currentHeight === 1 && remaining > maxTowers - towers.length) {
                currentHeight = 2; // Увеличиваем минимальную высоту, если осталось много кубиков
            }
        }
        
        // Если остались кубики, добавляем еще башни высотой 1
        while (remaining > 0 && towers.length < gridSize * gridSize) {
            towers.push({
                height: 1,
                x: -1,
                y: -1
            });
            remaining -= 1;
        }
        
        // Сортируем башни по высоте от высоких к низким
        towers.sort((a, b) => b.height - a.height);
        
        // Размещаем башни на сетке по спирали с учетом высоты
        // Начинаем с верхнего левого угла (дальше от наблюдателя)
        // и двигаемся по спирали к правому нижнему (ближе к наблюдателю)
        
        // Определяем начальную позицию (верхний левый угол)
        let startX = 0;
        let startY = 0;
        
        // Размещаем первую (самую высокую) башню в начальной точке
        if (towers.length > 0) {
            towers[0].x = startX;
            towers[0].y = startY;
        }
        
        // Размещаем остальные башни по соседству
        if (towers.length > 1) {
            // Создаем массив доступных соседних клеток
            let availableCells = [];
            
            // Функция для добавления соседних клеток в список доступных
            function addNeighborCells(x, y) {
                const neighbors = [
                    {x: x+1, y: y},   // справа
                    {x: x, y: y+1},   // снизу
                    {x: x-1, y: y},   // слева
                    {x: x, y: y-1}    // сверху
                ];
                
                for (const neighbor of neighbors) {
                    // Проверяем, что клетка в пределах сетки
                    if (neighbor.x >= 0 && neighbor.x < gridSize && 
                        neighbor.y >= 0 && neighbor.y < gridSize) {
                        
                        // Проверяем, что клетка не занята
                        if (H[neighbor.x][neighbor.y] === 0) {
                            
                            // Проверяем, что эта клетка еще не в списке доступных
                            if (!availableCells.some(cell => cell.x === neighbor.x && cell.y === neighbor.y)) {
                                // Вычисляем приоритет для сортировки
                                // Чем меньше сумма координат, тем дальше от наблюдателя
                                const priority = neighbor.x + neighbor.y;
                                availableCells.push({...neighbor, priority});
                            }
                        }
                    }
                }
            }
            
            // Добавляем соседей первой башни
            addNeighborCells(towers[0].x, towers[0].y);
            
            // Размещаем остальные башни
            for (let i = 1; i < towers.length; i++) {
                if (availableCells.length === 0) {
                    console.log("Не удалось разместить все башни рядом друг с другом");
                    break;
                }
                
                // Сортируем доступные клетки по приоритету
                // Для высоких башен выбираем клетки дальше от наблюдателя (с меньшим приоритетом)
                availableCells.sort((a, b) => a.priority - b.priority);
                
                // Выбираем подходящую клетку в зависимости от высоты башни
                let selectedCellIndex = 0;
                if (towers[i].height > 1) {
                    // Для высоких башен выбираем клетки дальше от наблюдателя
                    selectedCellIndex = 0; // Клетка с наименьшей суммой координат
                } else {
                    // Для низких башен (высотой 1) можно выбрать любую доступную клетку
                    selectedCellIndex = Math.min(availableCells.length - 1, Math.floor(availableCells.length / 2));
                }
                
                const selectedCell = availableCells[selectedCellIndex];
                
                // Размещаем башню
                towers[i].x = selectedCell.x;
                towers[i].y = selectedCell.y;
                
                // Помечаем клетку как занятую
                H[selectedCell.x][selectedCell.y] = towers[i].height;
                
                // Удаляем выбранную клетку из списка доступных
                availableCells.splice(selectedCellIndex, 1);
                
                // Добавляем соседей текущей башни в список доступных
                addNeighborCells(towers[i].x, towers[i].y);
            }
        }
        
        // Заполняем сетку высот из расположения башен
        for (const tower of towers) {
            if (tower.x >= 0 && tower.y >= 0) {
                H[tower.x][tower.y] = tower.height;
            }
        }
        
        // Подсчет фактического количества кубиков
        let totalCubes = 0;
        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                totalCubes += H[i][j];
            }
        }
        
        console.log(`Сгенерировано ${totalCubes} кубиков, целевое: ${targetCubes}`);
        return {heights: H, cubes: totalCubes};
    }

    // Отрисовка сцены
    function drawScene() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Фиксированный размер сетки 5x5
        const gridSize = 5;
        
        // Рисуем базовую плоскость
        drawBase(gridSize);
        
        // Подготавливаем колонки для отрисовки
        const columns = [];
        for(let i=0; i<gridSize; i++) {
            for(let j=0; j<gridSize; j++) {
                if (currentHeights[i] && currentHeights[i][j] > 0) {
                    columns.push({i, j, h: currentHeights[i][j]});
            }
        }
        }
        
        // Сортируем от дальних к ближним
        columns.sort((a, b) => (a.i + a.j) - (b.i + b.j));
        
        // Рисуем колонки кубов
        let renderedCount = 0;
        columns.forEach(col => {
            for(let z=0; z<col.h; z++) {
                renderedCount++;
                const color = palette[rand(0, palette.length-1)];
                drawCube(col.i, col.j, z, color);
            }
        });
        console.log(`Реально отрисовано: ${renderedCount} кубиков`);
    }

    // Показ сообщения
    function showMessage(text, type) {
        messageEl.textContent = text;
        messageEl.className = `message ${type}`;
        messageEl.style.opacity = 1;
        
        setTimeout(() => {
            messageEl.style.opacity = 0;
        }, 2000);
    }

    // Проверка ответа пользователя
    function checkAnswer() {
        const userAnswer = parseInt(userAnswerInput.value, 10);
        
        if (isNaN(userAnswer)) {
            showMessage('Введите число!', 'error');
            return;
        }
        
        if (userAnswer === totalCubes) {
            // Правильный ответ
            successCount++;
            
            if (successCount >= 3) {
                // Переход на следующий уровень
                currentLevel++;
                successCount = 0;
                levelEl.textContent = currentLevel;
                showMessage(`Поздравляем! Уровень ${currentLevel}`, 'level-up');
                
                // Обновляем хеш в URL
                updateLevelHash();
            } else {
                showMessage('Правильно!', 'success');
            }
            
            // Создаем новое задание
            setTimeout(createNewTask, 1500);
        } else {
            // Неправильный ответ
            successCount = 0;
            showMessage(`Неверно! Правильный ответ: ${Math.round(totalCubes)}`, 'error');
            progressEl.textContent = `${successCount}/3`;
            
            // Задержка перед новым заданием
            setTimeout(createNewTask, 2500);
        }
    }

    // Обработчики событий
    btnNext.addEventListener('click', checkAnswer);
    userAnswerInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            checkAnswer();
        }
    });

    // Обработчики для кнопки сжатия высоты
    btnFlatten.addEventListener('mousedown', () => {
        isFlattened = true;
        drawScene();
    });

    btnFlatten.addEventListener('mouseup', () => {
        isFlattened = false;
        drawScene();
        userAnswerInput.focus();
    });

    btnFlatten.addEventListener('mouseleave', () => {
        isFlattened = false;
        drawScene();
    });

    // Для поддержки тач-устройств
    btnFlatten.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isFlattened = true;
        drawScene();
    });

    btnFlatten.addEventListener('touchend', () => {
        isFlattened = false;
        drawScene();
        userAnswerInput.focus();
    });

    // Инициализация игры
    function initGame() {
        // Проверяем хеш в URL
        checkLevelFromHash();
        
        levelEl.textContent = currentLevel;
        createNewTask();
    }

    // Функция для проверки хеша в URL и установки соответствующего уровня
    function checkLevelFromHash() {
        const hash = window.location.hash.substr(1);
        if (hash && hash.length > 0) {
            try {
                const level = decodeLevelFromHash(hash);
                if (level && level > 0 && level <= 100) { // Ограничиваем максимальный уровень
                    currentLevel = level;
                    console.log(`Восстановлен уровень: ${level} из хеша`);
                }
            } catch (e) {
                console.log("Некорректный хеш уровня");
            }
        }
    }

    // Функция для обновления хеша в URL при изменении уровня
    function updateLevelHash() {
        const hash = encodeLevelToHash(currentLevel);
        window.location.hash = hash;
    }

    // Функция для генерации сложного хеша на основе номера уровня
    function encodeLevelToHash(level) {
        // Создаем случайную "соль" для усложнения хеша
        const salt = generateRandomString(5);
        
        // Преобразуем уровень в строку и добавляем соль
        const levelStr = level.toString().padStart(3, '0');
        
        // XOR шифрование с ключом
        let encoded = '';
        for (let i = 0; i < levelStr.length; i++) {
            const charCode = levelStr.charCodeAt(i);
            const keyChar = SECRET_KEY.charCodeAt(i % SECRET_KEY.length);
            encoded += String.fromCharCode(charCode ^ keyChar);
        }
        
        // Добавляем соль и время (для уникальности)
        const timestamp = Date.now() % 10000;
        const dataToEncode = salt + encoded + timestamp.toString();
        
        // Кодируем в Base64
        return btoa(dataToEncode).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
    }

    // Функция для декодирования хеша в номер уровня
    function decodeLevelFromHash(hash) {
        try {
            // Декодируем из Base64
            const decoded = atob(hash.replace(/-/g, '+').replace(/_/g, '/'));
            
            // Убираем соль (первые 5 символов) и timestamp (последние 4 символа)
            const encodedLevel = decoded.substr(5, 3);
            
            // XOR дешифрование с ключом
            let levelStr = '';
            for (let i = 0; i < encodedLevel.length; i++) {
                const charCode = encodedLevel.charCodeAt(i);
                const keyChar = SECRET_KEY.charCodeAt(i % SECRET_KEY.length);
                levelStr += String.fromCharCode(charCode ^ keyChar);
            }
            
            // Преобразуем в число
            return parseInt(levelStr, 10);
        } catch (e) {
            console.error("Ошибка декодирования хеша", e);
            return null;
        }
    }

    // Генерация случайной строки заданной длины
    function generateRandomString(length) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < length; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    // Запуск игры
    initGame();
})();
</script>
</body>
</html>
